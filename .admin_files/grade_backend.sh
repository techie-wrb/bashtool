#!/bin/bash

# Environment variable TERM was "dumb" on docker...
[ "$TERM" = "dumb" ] && export TERM=screen-256color

# Clears the screen
tput reset
BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
ORANGE=$(tput setaf 202)
RESET=$(tput sgr0)

section() {
    # Print '=' for however many columns there are
    # https://stackoverflow.com/a/5915913
    s=$(head -c "$(tput cols)" </dev/zero | tr '\0' '\075')
    echo -e "\n$BLUE""$s""$RESET"
}

subsection() {
    # Print '-' for however many columns there are
    # https://stackoverflow.com/a/5915913
    s=$(head -c "$(tput cols)" </dev/zero | tr '\0' '\055')
    echo -e "\n$YELLOW""$s""$RESET"
}

keepgoing() {
    echo -e "\nPress ""$CYAN""Enter""$RESET"" now to continue."
    read -r
}

check_hashes() {
    # This should be run before any file students could potentially edit.
    # Assumes you've added the relevant files to hash_gen.sh
    # usage: check_hashes
    # () creates a subshell, and so no need to cd back
    (
        cd .admin_files
        bash hash_gen.sh
        # cd ..
    )
    if diff .admin_files/hashes.txt .admin_files/grader_hashes.txt &>/dev/null; then
        :
        # echo "Hashes ok"
    else
        section
        echo -e "$RED\nDon't edit any of the autograder's files, or you will fail!$RESET"
        echo "Notice the files listed below, with the long hashes in front of them."
        echo -e "Those are the files you broke.\n"
        diff .admin_files/hashes.txt .admin_files/grader_hashes.txt
        echo -e "\nIf you are seeing this, then type:"
        echo "    $ $MAGENTA git log$RESET"
        echo "Then look at the log to find the first four letters of the hash of the instructor's last commit; copy it."
        echo "Then type:"
        echo "    $ $MAGENTA git checkout firstfourlettersofthehashoftheinstructorslastcommit fileorfolderyoubroke $RESET"
        echo -e "You must do this for each file you broke (or just the super-folder of the grader-files), and then re-run grade.sh.\n"
        grade=0
        echo "You edited our stuff, so you get a 0; see the output for details" >"$student_file"
        echo $grade >>"$student_file"
        exit 1
    fi
}
check_hashes

for python_package_name in Levenshtein; do
    if ! python3 -c "import $python_package_name"; then
        echo Install $python_package_name before proceeding.
        exit 1
    fi
done
if [ $language = "python" ]; then
    # Some OS's (OpenSuse) install pudb3 as pudb
    if command -v pudb3 >/dev/null 2>&1; then
        pudb3=pudb3
    else
        pudb3=pudb
    fi
    if ! command -v $pudb3 &>/dev/null; then
        echo "Install pudb3 before proceeding."
        exit 1
    fi
    for package_name in mypy black py2cfg; do
        if ! command -v $package_name &>/dev/null; then
            echo Install $package_name before proceeding.
            exit 1
        fi
    done
fi
if [ $language = "bash" ]; then
    for package_name in shellcheck shfmt; do
        if ! command -v $package_name &>/dev/null; then
            echo Install $package_name before proceeding.
            exit 1
        fi
    done
fi
if [ $language = "cpp" ]; then
    for package_name in clang-format make cppcheck gdb; do
        if ! command -v $package_name &>/dev/null; then
            echo Install $package_name before proceeding.
            exit 1
        fi
    done
fi
if [ $language = "rust" ]; then
    for package_name in rustc gdb rustfmt; do
        if ! command -v $package_name &>/dev/null; then
            echo Install $package_name before proceeding.
            exit 1
        fi
    done
fi

echo -e "Welcome to grade.sh!\n\n"
echo -e "    $MAGENTA""Magenta""$RESET" is bash/shell commands or paths to files.
echo -e "    $GREEN""Green""$RESET" is used to indicate a pass.
echo -e "    $RED""Red""$RESET" is used to indicate a fail.
echo -e "    $ORANGE""Orange""$RESET" marks the text of a header for a block of tests of a single type.
echo -e "    $CYAN""Cyan""$RESET" draws your attention to something you have to do.
echo -e "\nActually$CYAN read ALL the output generated by this script!\n$RESET"
echo -e "\nFor this particular assignment:"
if [ "$fuzzy_partial_credit" = false ]; then
    echo "* Differences in output are computed rigidly -- no partial credit!"
else
    echo "* Differences in output will award partial credit!"
fi
echo "* Each launch of your $main_file code must run in under $process_timeout seconds"
echo -e "\nPress ""$CYAN""Enter""$RESET"" now to continue."
read -r

grade_update() {
    # Updates grade and prints, based on the return code of preceeding statement
    # Expects grade for each unit/test to be 0-100
    # Usage: grade_update test_name points_to_add expected_retcode
    return_status=$?
    check_hashes
    echo -e "\nTest for: $1"
    if [ "$return_status" == "$3" ]; then
        if [ "$2" -lt 100 ]; then
            echo "$RED    This test gave you $2 more points$RESET"
        else
            echo "$GREEN    This test gave you $2 more points$RESET"
        fi
        ((grade = grade + "$2"))
    else
        echo "$RED    This test gave you 0 more points$RESET"
    fi
    ((num_tests = num_tests + 1))
}

build() {
    section
    echo -e "$ORANGE""Below here, we will attempt to build your tests.$RESET"
    echo -e "Any compilation warnings or errors indicate a problem with your code.\n"
    keepgoing
    subsection
    if [ "$language" = "rust" ]; then
        cargo clean
        cargo build
        if [ $? -eq 0 ]; then
            echo -e "$GREEN" "\nSuccess!$RESET All unit tests compiled.\n"
        else
            echo -e "$RED" "\nWARNING!$RESET Your code did not compile.\n"
            echo -e "$CYAN""Please fix these problems before proceeding"
            exit 1
        fi
    elif [ "$language" = "cpp" ]; then
        make clean
        echo -e "Building unit tests ...\n"

        make --silent unit_tests
        if [ $? -eq 0 ]; then
            echo -e "$GREEN" "\nSuccess!$RESET All unit tests compiled.\n"
        else
            echo -e "$RED" "\nWARNING!$RESET Cannot compile all unit tests.\n"
            echo -e "$CYAN""Please fix these problems before proceeding. See the test name for the relevant function."
            echo -e "Use the command:" "$MAGENTA make unit_tests" "$CYAN to check for compilation issues yourself."
            exit 1
        fi

        subsection
        echo -e "\nBuilding main program for standard input/output and argument tests ...\n"

        make --silent
        if [ $? -eq 0 ]; then
            echo -e "$GREEN" "\nSuccess!$RESET Main program compiled.\n"
        else
            echo -e "$RED" "\nWARNING!$RESET Main program did not compile.\n"
            echo -e "$CYAN" "Please fix these problems before proceeding. Corrections needed in $MAGENTA$main_file"
            echo -e "$CYAN Use the command:" "$MAGENTA make" "$CYAN to check for compilation issues yourself."
            exit 1
        fi
    fi
}

unit_tests() {
    # Executes a directory of our python unit tests.
    # Assumes they don't need any standard input (write a custom line for that).
    # Usage: unit_tests
    if [ "$language" = "cpp" ]; then
        glob_expr="tests/unit_tests/*.cpp"
        check_hashes
    elif [ "$language" = "python" ]; then
        glob_expr="tests/unit_tests/*.py"
    elif [ "$language" = "bash" ]; then
        glob_expr="tests/unit_tests/*.sh"
    elif [ "$language" = "rust" ]; then
        glob_expr="tests/unit_tests/*.rs"
    fi
    first="0"
    for testpath in $glob_expr; do
        if [ $first = "0" ]; then
            section
            echo "$ORANGE""Below here, we will run unit tests.""$RESET"
            echo "See the$MAGENTA ./tests/unit_tests/$RESET folder to view the code used for testing"
            first="1"
            keepgoing
        fi
        subsection
        expected_retcode=$(((RANDOM % 250) + 5))
        filename=$(basename "$testpath")
        if [ "$language" = "cpp" ]; then
            testname="$(basename "$filename" .cpp)"
            echo Running command: $ " $MAGENTA"timeout "$process_timeout" ./build/"$testname".out "$expected_retcode""$RESET"
            timeout "$process_timeout" ./build/"$testname".out "$expected_retcode"
        elif [ "$language" = "python" ]; then
            echo Running command: $ " $MAGENTA"timeout "$process_timeout" python3 tests/unit_tests/"$filename""$RESET"
            timeout "$process_timeout" python3 .admin_files/test_utils.py tests/unit_tests/"$filename" "$expected_retcode"
        elif [ "$language" = "bash" ]; then
            echo Running command: $ " $MAGENTA"timeout "$process_timeout" bash tests/unit_tests/"$filename" "$expected_retcode""$RESET"
            timeout "$process_timeout" bash tests/unit_tests/"$filename" "$expected_retcode"
        elif [ "$language" = "rust" ]; then
            testname="$(basename "$filename" .rs)"
            echo Running command: $ " $MAGENTA"timeout "$process_timeout" ./target/debug/"$testname" "$expected_retcode""$RESET"
            timeout "$process_timeout" ./target/debug/"$testname" "$expected_retcode"
        fi
        # TODO detect return code 0 and warn students not to use exit() ?
        if [ $? -eq "$expected_retcode" ]; then
            grade_update "$filename" 100 0
        else
            grade_update "$filename" 0 0
            if [[ "$IS_PIPELINE" ]] >/dev/null 2>&1; then
                :
            else
                if [ "$language" = "cpp" ]; then
                    debug_cmd=(gdb '--eval-command="break main"' '--eval-command="run"' --args ./build/"$testname".out 123)
                elif [ "$language" = "python" ]; then
                    debug_cmd=("$pudb3" "$testpath")
                elif [ "$language" = "bash" ]; then
                    debug_cmd=(bash -x "$testpath" 123)
                    # TODO a real bash debugger like bashdb?
                elif [ "$language" = "rust" ]; then
                    debug_cmd=(gdb '--eval-command="break main"' '--eval-command="run"' --args ./target/debug/"$testname" 123)
                fi
                echo -e "\nWe will now launch the debugger as follows:"
                echo -e "$ $MAGENTA" "${debug_cmd[@]}" "$RESET"
                keepgoing
                "${debug_cmd[@]}"
            fi
        fi
        check_hashes
    done
}

stdio_tests() {
    # Tests a python script (first and only arg) against directory of std-in/out
    # Saves outputs and diffs
    # Usage: stdio_tests main_file.py

    # For C++, build the student's main()
    if [ "$language" = "cpp" ]; then
        # $main_file_arguments should be unpacked, and not "$main_file_arguments",
        # or it will lead to an extra empty argument when not used.
        prog_name=("./build/program.out" $main_file_arguments)
    elif [ "$language" = "python" ]; then
        prog_name=(python3 "$1" $main_file_arguments)
    elif [ "$language" = "bash" ]; then
        prog_name=(bash "$1" $main_file_arguments)
    elif [ "$language" = "rust" ]; then
        prog_name=("cargo" "run" "--bin=program" $main_file_arguments)
    fi

    rm -rf tests/stdio_tests/outputs/*
    rm -rf tests/stdio_tests/goals/.*.swp
    first="0"
    for testpath in tests/stdio_tests/inputs/*.txt; do
        if [ $first = "0" ]; then
            section
            echo "$ORANGE""Below here, we will run Standard Input/Output (std io) tests.""$RESET"
            echo "See the$MAGENTA ./tests/stdio_tests/$RESET folder for inputs used, your outputs, correct outputs, and diffs"
            first="1"
            keepgoing
        fi
        filename=$(basename "$testpath")
        testname="${filename%_*}"
        subsection
        echo -e "Running command: $ $MAGENTA" timeout "$process_timeout" "${prog_name[@]}" "<$testpath" ">tests/stdio_tests/outputs/$testname"_output.txt"$RESET"
        t0=$(date +%s.%N)
        # If we did not unpack "$main_file_arguments" above, we could unpack it here, with ${prog_name[@]} instead:
        timeout "$process_timeout" "${prog_name[@]}" <"$testpath" >tests/stdio_tests/outputs/"$testname"_output.txt 2>/dev/null
        check_hashes
        echo -e "Your main driver program took the following duration of time to run on the above sample:"
        your_time=$(echo "print($(date +%s.%N) - $t0)" | python3)
        echo -e "    $your_time seconds"
        if [ "$fuzzy_partial_credit" = false ]; then
            diff tests/stdio_tests/goals/"$testname"_output.txt tests/stdio_tests/outputs/"$testname"_output.txt >/dev/null 2>&1
            grade_update "$testpath" 100 0
            # Just a useless placeholder here:
            fuzzy_diff=0
        else
            fuzzy_diff=$(python3 .admin_files/fuzzydiffer.py "tests/stdio_tests/goals/$testname"_output.txt tests/stdio_tests/outputs/"$testname"_output.txt)
            grade_update "$testpath" "$fuzzy_diff" 0
        fi
        diff tests/stdio_tests/goals/"$testname"_output.txt tests/stdio_tests/outputs/"$testname"_output.txt >/dev/null 2>&1
        if [ "$?" -eq 0 ] || [ "$fuzzy_diff" -eq 100 ]; then
            # bash's no-op is most clear positive logic here...
            :
        else
            if [[ "$IS_PIPELINE" ]] >/dev/null 2>&1; then
                :
            else
                if [ "$language" = "cpp" ]; then
                    # http://mywiki.wooledge.org/BashFAQ/050
                    debug_cmd=(gdb '--eval-command="break main"' --args "${prog_name[@]}")
                elif [ "$language" = "python" ]; then
                    debug_cmd=("$pudb3" "$1" $main_file_arguments)
                elif [ "$language" = "bash" ]; then
                    debug_cmd=(bash -x "$1" $main_file_arguments)
                    # TODO a real bash debugger like bashdb?
                elif [ "$language" = "rust" ]; then
                    debug_cmd=(gdb '--eval-command="break main"' --args "${prog_name[@]}")
                fi
                echo -e "\nThese are the differences between the goal output (left) and your standard output (right)."
                delta --max-line-length 0 --wrap-max-lines unlimited --side-by-side \
                    tests/stdio_tests/goals/"$testname"_output.txt tests/stdio_tests/outputs/"$testname"_output.txt
                echo -e "\nWe will now launch the debugger as follows:"
                echo -e "$ $MAGENTA" "${debug_cmd[@]}" "$RESET"
                echo -e "while YOU copy the contents of $ $MAGENTA cat $testpath $RESET by hand"
                keepgoing
                "${debug_cmd[@]}"
                check_hashes
            fi
        fi
    done
}

arg_tests() {
    # Tests a python script (first and only arg) against directory of std-in/out
    # Saves outputs and diffs
    # Usage: arg_tests main_file.py

    # For C++, build the student's main()
    if [ "$language" = "cpp" ]; then
        prog_name=("./build/program.out")
    elif [ "$language" = "python" ]; then
        prog_name=(python3 "$1")
    elif [ "$language" = "bash" ]; then
        prog_name=(bash "$1")
    elif [ "$language" = "rust" ]; then
        prog_name=("cargo" "run" "--bin=program")
    fi

    rm -rf tests/arg_tests/outputs/*
    rm -rf tests/arg_tests/goals/.*.swp
    first="0"
    for testpath in tests/arg_tests/args/*.txt; do
        if [ $first = "0" ]; then
            section
            echo "$ORANGE""Below here, we will run argument-based tests.""$RESET"
            echo "See the$MAGENTA ./tests/arg_tests/$RESET folder for arguments passed, your outputs, correct outputs, and diffs"
            first="1"
            keepgoing
        fi
        filename=$(basename "$testpath")
        testname="${filename%_*}"
        read -ra testargs <"$testpath"
        subsection
        echo -e "Running command: $ $MAGENTA" timeout "$process_timeout" "${prog_name[@]}" "${testargs[@]}" "$RESET"
        t0=$(date +%s.%N)
        timeout "$process_timeout" "${prog_name[@]}" "${testargs[@]}" 2>/dev/null
        check_hashes
        echo -e "Your main driver program took the following duration of time to run on the above sample:"
        your_time=$(echo "print($(date +%s.%N) - $t0)" | python3)
        echo -e "    $your_time seconds"
        if [ "$fuzzy_partial_credit" = false ]; then
            diff tests/arg_tests/goals/"$testname"_output.txt tests/arg_tests/outputs/"$testname"_output.txt >/dev/null 2>&1
            grade_update "$testpath" 100 0
            # Just a useless placeholder here:
            fuzzy_diff=0
        else
            fuzzy_diff=$(python3 .admin_files/fuzzydiffer.py "tests/arg_tests/goals/$testname"_output.txt tests/arg_tests/outputs/"$testname"_output.txt)
            grade_update "$testpath" "$fuzzy_diff" 0
        fi
        diff tests/stdio_tests/goals/"$testname"_output.txt tests/stdio_tests/outputs/"$testname"_output.txt >/dev/null 2>&1
        if [ "$?" -eq 0 ] || [ "$fuzzy_diff" -eq 100 ]; then
            # bash's no-op is most clear positive logic here...
            :
        else
            if [[ "$IS_PIPELINE" ]] >/dev/null 2>&1; then
                :
            else
                if [ "$language" = "cpp" ]; then
                    # http://mywiki.wooledge.org/BashFAQ/050
                    debug_cmd=(gdb '--eval-command="break main"' --args "${prog_name[@]}" "${testargs[@]}")
                elif [ "$language" = "python" ]; then
                    debug_cmd=("$pudb3" "$1" "${testargs[@]}")
                elif [ "$language" = "bash" ]; then
                    debug_cmd=(bash -x "$1" "${testargs[@]}")
                    # TODO a real bash debugger like bashdb?
                elif [ "$language" = "rust" ]; then
                    debug_cmd=(gdb '--eval-command="break main"' --args "${prog_name[@]}" "${testargs[@]}")
                fi
                echo -e "\nThese are the differences between the goal file output (left) and your file output (right)."
                delta --max-line-length 0 --wrap-max-lines unlimited --side-by-side \
                    tests/arg_tests/goals/"$testname"_output.txt tests/arg_tests/outputs/"$testname"_output.txt
                echo -e "\nWe will now launch the debugger as follows:"
                echo -e "$ $MAGENTA" "${debug_cmd[@]}" "$RESET"
                keepgoing
                "${debug_cmd[@]}"
                check_hashes
            fi
        fi
    done
}

cfg_tests() {
    # Set the cutoff limit for SVG/DOT diffs. The student still needs to generate a
    # graph reasonably close to the original otherwise it's too easy to hardcode
    # solutions
    fuzzy_cutoff=60

    # Tests that student implemented py files for each tests/cfg_tests/*.svg file
    # Usage: cfg_tests

    # For C++, build the student's main()
    if [ "$language" = "cpp" ]; then
        :
        # TODO which cfg generator to use?
    elif [ "$language" = "python" ]; then
        cfg_generator=py2cfg
    elif [ "$language" = "bash" ]; then
        :
        # TODO Probably no cfg generator exists, or will?
    fi

    first="0"
    for testpath in tests/cfg_tests/goals/*.txt; do
        if [ $first = "0" ]; then
            section
            echo "$ORANGE""Below here, we will run control-flow-graph based tests.""$RESET"
            echo "See the ./tests/cfg_tests/ folder for more detail."
            first="1"
            keepgoing
            rm -rf *.svg
        fi
        subsection

        filename=$(basename $testpath)
        filename="${filename%.*}"

        echo "Running command: $ $MAGENTA $cfg_generator src/${filename}.py --diffable tests/cfg_tests/outputs/${filename}.txt$RESET"
        $cfg_generator src/${filename}.py --diffable tests/cfg_tests/outputs/${filename}.txt

        if diff "tests/cfg_tests/outputs/${filename}.txt" "./$testpath" &>/dev/null; then
            fuzzy_diff=$(python3 .admin_files/fuzzydiffer.py ${filename}_cfg.svg tests/cfg_tests/goal_cfgs/${filename}_cfg.svg)
            if (("$fuzzy_diff" < "$fuzzy_cutoff")); then
                grade_update "Your code CFG match with $testpath test" 0 0
            else
                echo "" >/dev/null
                grade_update "Your code CFG match with $testpath test" 100 0
            fi
        else
            grade_update "Your code CFG match with $testpath test" 0 0
            if [[ "$IS_PIPELINE" ]] >/dev/null 2>&1; then
                :
            else
                if [ "$language" = "cpp" ]; then
                    :
                    # TODO
                elif [ "$language" = "python" ]; then
                    # TODO what if the file had args?
                    debug_cmd=("$cfg_generator" "src/${filename}.py" "--debug")
                elif [ "$language" = "bash" ]; then
                    :
                    # TODO
                elif [ "$language" = "rust" ]; then
                    :
                    # TODO
                fi
                echo -e "\nWe will now launch the debugger as follows:"
                echo -e "$ $MAGENTA" "${debug_cmd[@]}" "$RESET"
                keepgoing
                "${debug_cmd[@]}"
            fi
        fi
    done
    mv ./*.svg ./tests/cfg_tests/output_cfgs/ &>/dev/null
}

doctest_tests() {
    # Tests that student implemented py files for each tests/cfg_tests/*.svg file
    # Usage: cfg_tests

    # For C++, build the student's main()
    if [ "$language" = "cpp" ]; then
        :
        doctest_string="junk"
        # TODO are there any doctest options for cpp?
    elif [ "$language" = "python" ]; then
        doctest_string="doctest.testmod"
        doctest_command="python3 -m doctest -v $1"
    elif [ "$language" = "bash" ]; then
        :
        doctest_string="junk"
        # likely these exist for bash
    elif [ "$language" = "rust" ]; then
        :
        doctest_string="junk"
        # likely these exist for rust
    fi
    if grep "$doctest_string" "$1" &>/dev/null; then
        section
        echo "$ORANGE""Below here, we will run doctest based tests.""$RESET"
        echo "See the function docstring in $1 itself for more detail."
        keepgoing

        echo "Running command: $ $MAGENTA $doctest_command $RESET"
        if $doctest_command &>/dev/null; then
            grade_update "Doctests in function docstring" 100 0
        else
            grade_update "Doctests in function docstring" 0 0
            if [[ "$IS_PIPELINE" ]] >/dev/null 2>&1; then
                :
            else
                if [ "$language" = "cpp" ]; then
                    :
                    # TODO
                elif [ "$language" = "python" ]; then
                    $doctest_command
                    debug_cmd=("$pudb3" "$1" $main_file_arguments)
                elif [ "$language" = "bash" ]; then
                    :
                    # TODO
                elif [ "$language" = "rust" ]; then
                    :
                    # TODO
                fi
                echo -e "\nWe will now launch the debugger as follows:"
                echo -e "$ $MAGENTA" "${debug_cmd[@]}" "$RESET"
                keepgoing
                "${debug_cmd[@]}"
            fi
        fi
    fi
}

files_exist() {
    # https://stackoverflow.com/questions/4069188/how-to-pass-an-associative-array-as-argument-to-a-function-in-bash
    # https://stackoverflow.com/questions/3112687/how-to-iterate-over-associative-arrays-in-bash
    local -n arr=$1
    first="0"
    for exist_file in "${!arr[@]}"; do
        if [ $first = "0" ]; then
            section
            echo "$ORANGE""Below here, we will run tests for existence of files and their type data:""$RESET"
            first="1"
            keepgoing
        fi
        subsection
        echo -e "Checking for the existence of '$exist_file' and its containing type of data:" "'${arr["$exist_file"]}.'"
        [ -f "$exist_file" ] && file "$exist_file" | grep "${arr["$exist_file"]}" >/dev/null 2>&1
        grade_update \""$exist_file\" with type containing \"${arr["$exist_file"]}\" existed" 100 0
    done
}

static_analysis() {
    section
    echo -e "$ORANGE""Below here, we present suggestions from automatic static analysis:""$RESET"
    keepgoing
    subsection
    if [ "$language" = "cpp" ]; then
        echo "Running command: $" "$MAGENTA cppcheck --enable=all --suppress=missingIncludeSystem --error-exitcode=1 --language=c++ ./*.cpp ./*.h ./*.hpp$RESET"
        echo -e "\nSee $ ""$MAGENTA man cppcheck$RESET and $ $MAGENTA cppcheck --help$RESET for more detail.\n"
        cppcheck --enable=all --suppress=missingIncludeSystem --error-exitcode=1 --language=c++ ./src/*.cpp ./src/*.h ./src/*.hpp
    elif [ "$language" = "python" ]; then
        echo "Running command: $" "$MAGENTA mypy --strict --disallow-any-explicit ./src/*.py$RESET"
        echo -e "\nSee $ ""$MAGENTA man mypy$RESET and $ $MAGENTA mypy --help$RESET for more detail.\n"
        mypy --strict --disallow-any-explicit ./src/*.py
    elif [ "$language" = "bash" ]; then
        echo "Running command: $" "$MAGENTA shellcheck --check-sourced --external-sources $main_file $RESET"
        echo -e "\nSee $ ""$MAGENTA man shellcheck$RESET and $ $MAGENTA shellcheck --help$RESET for more detail.\n"
        shellcheck --check-sourced --external-sources "$main_file"
    elif [ "$language" = "rust" ]; then
        :
        # cargo check
        # This is just basically the first step of compilation by cargo run...
        # Is there any even more deep check? I doubt it...
    fi
    grade_update "static analysis / typechecking" 100 0
}

check_formatting() {
    section
    echo -e "$ORANGE""Below here, we present suggestions about automatic code formatting style:""$RESET"
    echo "Your code may be correct, but does not adhere to style formatting guidelines."
    keepgoing
    subsection
    if [ "$language" = "cpp" ]; then
        echo "Running command: $" "$MAGENTA python3 .admin_files/run-clang-format.py -r --style=LLVM .$RESET"
        echo -e "\nSee $ ""$MAGENTA"" clang-format --help$RESET for more detail.\n"
        python3 .admin_files/run-clang-format.py -r --style=LLVM .
        # CI needed this script instead of local command?
        # clang-format --dry-run --Werror --style=Microsoft *.cpp *.h *.hpp
    elif [ "$language" = "python" ]; then
        echo "Running command: $" "$MAGENTA black --check ./src/*.py$RESET"
        echo -e "\nSee $ ""$MAGENTA man black$RESET and $ $MAGENTA black --help$RESET for more detail."
        echo -e "If you are passing locally, but not on the server, or vice-versa, check: $MAGENTA black --version$RESET\n"
        black --check ./src/*.py
    elif [ "$language" = "bash" ]; then
        echo "Running command: $" "$MAGENTA shfmt -i 4 -d .$RESET"
        # https://www.arachnoid.com/linux/beautify_bash/
        # https://github.com/mvdan/sh#shfmt
        # Format in-place with: ./go/bin/shfmt -i 4 -w .
        echo -e "\nSee $ ""$MAGENTA"" shfmt --help$RESET for more detail.\n"
        shfmt -i 4 -d .
    elif [ "$language" = "rust" ]; then
        echo "Running command: $" "$MAGENTA rustfmt --check ./src/*.rs$RESET"
        echo -e "\nSee $ ""$MAGENTA rustfmt --help$RESET for more detail."
        rustfmt --check ./src/*.rs
    fi
    grade_update "auto-format style check" 100 0
}

######## Init -> ########
num_tests=0
grade=0
check_hashes

if [ ! "$(uname)" = Linux ]; then
    echo "Run this on a Linux platform!"
    exit 1
fi

if [[ ! "$IS_PIPELINE" ]] >/dev/null 2>&1; then
    if [ "$language" = "cpp" ]; then
        :
        # TODO Find a good C++ flowchart generator and run here
    elif [ "$language" = "python" ]; then
        section
        for pyfile in ./src/*.py; do
            py2cfg "$pyfile" &>/dev/null
        done
        echo -e "$ORANGE""Control Flow Graph (CFG)""$RESET"
        echo "You may find the following files helpful in thinking about your code:"
        mv ./*.svg ./tests/cfg_tests/output_cfgs/ &>/dev/null
        ls ./tests/cfg_tests/output_cfgs/*.svg
        echo "You can open them in your favorite Web browser, or Inkscape"
        keepgoing
    elif [ "$language" = "bash" ]; then
        :
        # TODO A flowchart generator for bash does not likely exist...
    elif [ "$language" = "rust" ]; then
        :
        # TODO a flowchart generator?
    fi
fi
######## <- Init ########

######## Standard tests -> ########
shopt -s nullglob
if [ "$language" = "cpp" ] || [ "$language" = "rust" ]; then
    build
fi
if [ "$enable_static_analysis" = true ]; then
    static_analysis
fi
unit_tests
stdio_tests "$main_file"
arg_tests "$main_file"
doctest_tests "$main_file"
cfg_tests
files_exist file_arr
if [ "$enable_format_check" = true ]; then
    check_formatting
fi
shopt -u nullglob
######## <- Standard tests ########

######## Variable custom tests -> ########
first="0"
for func in $(compgen -A function); do
    if grep -q "^custom_test" - <<<"$func"; then
        if [ $first = "0" ]; then
            section
            echo "$ORANGE""Below here, we present custom tests.""$RESET"
            echo "If you want to see what's happening in the custom tests,"
            echo "then read the tests themselves at the bottom of the grade.sh file."
            first="1"
            keepgoing
        fi
        custom_test_score=-1
        check_hashes
        subsection
        echo "* Doing custom test: $func"
        $func
        check_hashes
        if [ "$custom_test_score" -ne "-1" ]; then
            grade_update "$func" "$custom_test_score" 0
        fi
    fi
done
######## <- Variable custom tests ########

######## Cleanup -> ########
rm -rf __pycache__
rm -rf .admin_files/__pycache__
rm -rf .mypy_cache
rm -rf unit_tests/.mypy_cache
rm -rf ./build/*.out
rm -rf ./*.out ./*.o
######## <- Cleanup ########

######## Reporting and grading -> ########
grade=$(echo "print(int($grade / $num_tests))" | python3)
section
echo -e "$ORANGE""Results\n""$RESET"
echo -e "Your tentative grade is:\n$grade" >$student_file
cat $student_file
if [[ ! "$IS_PIPELINE" ]] >/dev/null 2>&1; then
    rm $student_file
fi

if [ -f student_git_pass_threshold.txt ]; then
    pass_threshold=$(cat student_git_pass_threshold.txt)
    check_hashes
else
    pass_threshold=70
fi
notdone=$(python3 -c "print($grade < $pass_threshold)")
check_hashes
perfect=$(python3 -c "print($grade == 100)")
echo -e "\n    This is your" "$CYAN" "ESTIMATED" "$RESET" "grade."
echo "    Your" "$CYAN" "OFFICIAL" "$RESET" "grade can be found in git-classes, after you push your changes."
echo "    Navigate to the" "$CYAN" "Build > Jobs" "$RESET" "menu, and click the" "$CYAN" "Status" "$RESET" "icon for the LATEST job."
echo "    Your official grade" "$RED" "may differ from what you see here." "$RESET"

if [ "$notdone" == "True" ]; then
    echo -e "$RED\nYou're not passing yet.$RESET"
    echo -e "To see why, run this script in debug mode!\n"
    exit 1
else
    if [ "$perfect" == "True" ]; then
        echo -e "$GREEN\nCongratulations, now go check the CI/CD!\n$RESET"
    else
        echo -e "$GREEN\nYou're passing;$RESET decide how much you want the extra points!\n"
    fi
    exit 0
fi
######## <- Reporting and grading ########
